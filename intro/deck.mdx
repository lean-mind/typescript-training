import {CodeSurfer} from "code-surfer";
import defaultTheme, {highlight} from 'mdx-deck/themes'
import {Notes, Appear} from 'mdx-deck'

import {Logo, JavaScriptRepl} from '../components'
import tsLogo from '../assets/ts-logo.svg'
import superset from '../assets/superset.png'
import trophy from '../assets/trophy.png'
import rankingChart from '../assets/rankingChart.png'
import rankingTable from '../assets/rankingTable.JPG'

export const theme = {
  ...defaultTheme,
  ...highlight
}

# Introducción a TypeScript

<img src={tsLogo}/>

<Logo/>

---

## ¿Qué es TypeScript?

<Appear>

### Superset de JavaScript

<img src={superset}/>

</Appear>

<Logo/>

<Notes>
    - Lenguaje tipado
    - No se puede ejecutar directamente. Se transpila a JS
    - Se puede ejecutar TS con ts-node que transpila on the fly
    - Significa que puedes usar JS perfectamente junto con TS
    - Incluye funcionalidades próximas de JS (esNext)
</Notes>

---

## Tipos

<Logo/>

---

<CodeSurfer>

```js title="Declaración en JavaScript"
function add(x, y) {
  return x + y
}
```

</CodeSurfer>

<Logo/>

---

<JavaScriptRepl
  title="Sumar en JavaScript"
/>

<Notes>

  - ¿Qué hace esa función en JS?

  - ¿Qué podría recibir de entrada?
    - 'a' + 1
    - 1 + 'a'
    - 1 + 1
    - 1 + undefined
    - 'a' + undefined
    - true + true
    - [] + 1

  - Ya, pero si TypeScript no funciona en ejecución, ¿cómo evito que me metan un string? Pues usando value objects cuando trabajas con números.

</Notes>

<Logo/>

---

<CodeSurfer>

```typescript title="Tipos"
function add(x: number, y: number): number {
  return x + y
}
```

```diff title="Tipos" 1[1:14,25:25,34:34,44],2:3
```
```diff title="Tipos" 1[15:24,26:33,35:43]
```
```diff title="Tipos" 1[35:43]
```

</CodeSurfer>

<Logo/>

---

## Tipos avanzados


<Logo/>

---

<CodeSurfer>

```typescript title="Tipos avanzados"
interface Person {
  id: string
  name: string
  age: number
}
```

</CodeSurfer>

<Logo/>

---

<CodeSurfer>

```typescript title="Tipos avanzados"
function buildPerson({
  id = '1',
  name = 'Bruce Wayne',
  age = 18
}: Partial<Person> = {}): Person {
  return {
    id,
    name,
    age
  }
}
```

```diff title="Tipos avanzados" 2:5
```
```diff title="Tipos avanzados" 2:5[1:19]
```
```diff title="Tipos avanzados" 5[19:23]
```
```diff title="Tipos avanzados" 5[25:32]
```

</CodeSurfer>

<Notes>

  - ¿Qué hace esta función?
  - ¿Qué aporta la deconstrucción de parámetros?
  - ¿Qué ventajas tiene llamar a una función con objetos en lugar de usar sus parámetros por separado?
  - ¿Qué pasaría al invocar la función con un objeto con solo el atributo name?
  - ¿Se puede llamar a la función sin parámetros?

</Notes>

<Logo/>

---

## Genéricos


<Logo/>

---

## Genéricos

<CodeSurfer>

```typescript
class Lista<T> {
    private values: Array<T>
}

export interface UseCase<Input, Output> {
    exec(input: Input): Output
}
```

</CodeSurfer>

<Notes>

  - Útil en el desarrollo, no existe/traspila en Javascript
  - Permite definir qué va a realizar un objeto sin saber cómo lo hará
  - No poner un tipo sería como usar any, por lo tanto aceptaría cualquier tipo de parámetro
  - Evita el uso de **any**!!!!!!!, tipando

</Notes>

<Logo/>

---

## Mejor gestión de la herencia

<Logo/>

---

## Mejor gestión de la herencia

<CodeSurfer>

```typescript
abstract class CustomerAbstractRepository implements CustomerRepository {
    abstract write(customers: Customer[]): void

    read(): Customer[] {
        ...read customers
    }
}
```

```typescript
class CustomerRepository extends CustomerAbstractRepository {
    write(customers: Customer[]): void {
        ...write customers
    }
}

class CustomerLegacyRepository extends CustomerAbstractRepository {
    write(customers: Customer[]): void {
        ...write customers at legacy repository
    }
}
```

</CodeSurfer>

<Notes>
  - Aprovecha la potencia de objetos
  - Permite definir una API de comportamiento ocultando comportamiento interno
  - Facilita compartir código entre entidades
</Notes>

<Logo/>

---

## ¿Por qué TypeScript?

  - Mejora la experiencia de desarrollo
  - Más fácil de mantener
  - Reduce costes

<Notes>
  - Bien aplicado reduce incertidumbre gracias al tipado y visibilidad de atributos/métodos/funciones
  - Disminuye el tiempo necesario para tomar el control de código legacy o que hace tiempo que no se toca
</Notes>

<Logo/>

---

### Testeo estático

<img src={trophy} style='height: 70vh'/>

<Notes>
  - Kent C. Dodds
  - Ejemplo: tsc intro/trophyExample/example.trophyTS.ts
</Notes>

<Logo/>

---

### Aprovecha mejor las herramientas del IDE

<Notes>
    - Refactorizar código
    - Inline variables
    - Ejemplo: trophyExample
</Notes>

<Logo/>

---

### Añade funcionalidades futuras de JS

- Stage 3 de la TC39

<Logo/>

<Notes>
  - Faltan notas
</Notes>

---

### Crecimiento año tras año

<Logo/>

---

## JSDoc vs TypeScript

<Notes>
  - ¿Qué alternativa elegir cuando estás perdiendo el control de tu código?
</Notes>

<Logo/>
