import {CodeSurfer} from "code-surfer";
import defaultTheme, {highlight} from 'mdx-deck/themes'
import {Notes, Appear} from 'mdx-deck'

import {Logo, JavaScriptRepl} from '../components'
import tsLogo from '../assets/ts-logo.svg'
import superset from '../assets/superset.png'

export const theme = {
  ...defaultTheme,
  ...highlight
}

# Introducción a TypeScript

<img src={tsLogo}/>

<Logo/>

---

## ¿Qué es TypeScript?

<Appear>

### Superset de JavaScript

<img src={superset}/>

</Appear>

<Logo/>

---

## Tipos

<Logo/>

---

<CodeSurfer>

```js title="Declaración en JavaScript"
function add(x, y) {
  return x + y
}
```

</CodeSurfer>

<Logo/>

---

<JavaScriptRepl
  title="Sumar en JavaScript"
/>

<Notes>

  - ¿Qué hace esa función en JS?

  - ¿Qué podría recibir de entrada?
  'a' + 1
  1 + 'a'
  1 + 1
  1 + undefined
  'a' + undefined
  true + true

  - Ya, pero si TypeScript no funciona en ejecución, ¿cómo evito que me metan un string? Pues usando value objects cuando trabajas con números.

</Notes>

<Logo/>

---

<CodeSurfer>

```typescript title="Tipos"
function add(x: number, y: number): number {
  return x + y
}
```

```diff title="Tipos" 1[1:14,25:25,34:34,44],2:3
```
```diff title="Tipos" 1[15:24,26:33,35:43]
```
```diff title="Tipos" 1[35:43]
```

</CodeSurfer>

<Logo/>

---

## Tipos avanzados


<Logo/>

---

<CodeSurfer>

```typescript title="Tipos avanzados"
interface Person {
  id: string
  name: string
  age: number
}
```

</CodeSurfer>

<Logo/>

---

<CodeSurfer>

```typescript title="Tipos avanzados"
function buildPerson({
  id = '1',
  name = 'Bruce Wayne',
  age = 18
}: Partial<Person> = {}): Person {
  return {
    id,
    name,
    age
  }
}
```

```diff title="Tipos avanzados" 2:5
```
```diff title="Tipos avanzados" 2:5[1:19]
```
```diff title="Tipos avanzados" 5[19:23]
```
```diff title="Tipos avanzados" 5[25:32]
```

</CodeSurfer>

<Notes>

  - ¿Qué hace esta función?
  - ¿Qué aporta la deconstrucción de parámetros?
  - ¿Qué ventajas tiene llamar a una función con objetos en lugar de usasr sus parámetros por separado?
  - ¿Qué pasaría al invocar la función con un objeto con solo el atributo name ?
  - ¿Se puede llamar a la función sin parámetros?

</Notes>

<Logo/>

---

## Genéricos


<Logo/>

---

## Genéricos

<CodeSurfer>

```typescript
class Lista<T> {
    private values: Array<T>
}

export interface UseCase<Input, Output> {
    exec(input: Input): Output
}
```

</CodeSurfer>

<Notes>

  - Útil en el desarrollo, no existe/traspila en Javascript
  - Permite definir qué va a realizar un objeto sin saber cómo lo hará
  - Evita el uso de **any**, tipando los parámetros,

</Notes>

<Logo/>

---

## Mejor gestión de la herencia

<Logo/>

---

## Mejor gestión de la herencia

<CodeSurfer>

```typescript
abstract class CustomerAbstractRepository {
    read(): Customer[]
}
```

```typescript
class CustomerRepository extends CustomerAbstractRepository {
    write() {
        ...write customers
    }
}

class CustomerLegacyRepository extends CustomerAbstractRepository {
    write() {
        ...write customers at legacy repository
    }
}
```

</CodeSurfer>

<Notes>
  - Aprovecha la potencia de objetos
  - Permite definir una API de comportamiento ocultando comportamiento interno
  - Facilita compartir código entre entidades
</Notes>

<Logo/>

---


## ¿Por qué TypeScript?

### Mejora de la experiencia y reducción del costes de desarrollo

<Notes>
    - Bien aplicado reduce incertidumbre gracias al tipado y visibilidad de atributos/métodos/funciones
    - Disminuye el tiempo necesario para tomar el control de código legacy o que hace tiempo que no se toca

</Notes>

<Logo/>

---

### Testeo estático


<Notes>

</Notes>

<Logo/>

---

### Mas fácil de mantener

<Logo/>

---

### Aprovecha mejor las herramientas del IDE

<Notes>
    - Refactorizar código
    - Inline variables
</Notes>

<Logo/>

---

### Añade funcionalidades futuras de JS

- Stage 3 de la TC39

<Logo/>

---

### Crecimiento año tras año

<Logo/>

---

## JSDoc vs TypeScript

<Logo/>

