import { CodeSurfer } from 'code-surfer'
import { Logo } from '../components'
import tsLogo from '../assets/ts-logo.svg'


# Introducción a TypeScript (Parte 2)

<img src={tsLogo}/>

<Logo/>
<Notes>

  -

</Notes>

---

<CodeSurfer>

```ts title="Diferencias entre tipos y valores"
type Person = {
  name: string
  age?: number
}

const person: Person = {
  name: 'Antonio'
}
```

```diff title="Palabras reservadas" 1[1:4],6[1:5]



```ts title="Diferencias entre tipos"
function getInfo ({ name, age = 18 }: Person): string {
  return `${name} tiene ${age} años`
}

console.log(getInfo(person))
```

</CodeSurfer>

<Logo/>
<Notes>

  - Diferencias entre tipos
  // Mejorar
  - Los tipos se definen con dos puntos
  - La declaración de los objectos se rellenan con dos puntos
  // ^
  - Los valores por defecto van con un "igual"

</Notes>

---

## Tipos básicos

---

<CodeSurfer>

```ts title="string"
  const name: string

```

```ts title="number"
  const age: number
```

```ts title="bigint (es2020)"
  const euros: bigint
```

```ts title="boolean"
  const isRich: boolean
```

```ts title="symbol"
  const immutable: Symbol('secretkey')
```

```ts title="void"
  function foo(): void {
    ...
  }
```

```ts title="undefined (JS)"
  const irrelevant = undefined
```

```ts title="null (JS)"
  const sqlReference: null = null

  // tsconfig: strictNullChecks
```

</CodeSurfer>

<Logo/>

<Notes>

  - Todos los tipos en TypeScript se crean en base a los tipos primitivos. Por eso son primitivos ;)
  - number vs bigint
  - bigint: 64bits. 9.007.199.254.740.991. Upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers
  - No se pueden mezclar number con bigint. Hay que convertir antes
  - perdida de procesión al convertir a number
  - TODO: Symbol: Starting with ECMAScript 2015, symbol is a primitive data type, just like number and string
  -    únicos inmutables, pueden ser utilizados para identificar propiedades de los objetos
  - void: no data.
  - null (cero en operaciones matemáticas)
  - undefined: optional parameters not undefined

</Notes>

---
  ## Tipos básicos

---

<CodeSurfer>

```typescript title="Tipos literales"
type Language = 'typescript' | 'bash' | 'sql'
```

```ts title="Funciones"
type Fn = (parameter: number) => string

function foo(name: string, call: Fn) { ... }

```

```ts title="Array"
type Languages = Array<Language>
type Languages = Language[]

const skills: Languages = ['sql', 'typescript']
```

```ts title="Tupla"
type Pairs = [Language, number]
type FullName = [string, string, string?]

const foo: FullName = ['Juan']
const foo: FullName = ['Juan', 'González']
const foo: FullName = ['Juan', 'González', 'Pérez']
const foo: FullName = ['Juan', 'González', 'Pérez', 'Gómez']
```

```diff title="tuplas inválidas" 4,7
```

```ts title="Enum"
enum Level {
  Entry,
  Middle,
  Top,
  TenX
}
```

```ts title="Enum (inicializamos valores)"
enum Level {
  Entry = 3,
  Middle,
  Top,
  TenX
}
```

```ts title="Enum (inicializamos valores)"
enum Level {
  Entry = 'learning',
  Middle,
  Top,
  TenX
}
```

```ts title="Enum "
enum Level {
  Entry = 'learning',
  Middle = 'keep it up',
  Top = 'very good',
  TenX = 'really?'
}
```

```ts title="object"
  const developer: { name: string, age: number } = { name: 'Segismundo', age: 69 }
```

```ts title="¿Por qué no es una buena práctica?"
  const developer: { name: string, age: number } = { name: 'Segismundo', age: 69 }
```

```ts title="any"
  const apiResponse: any = {hiddenAttribute: 'sssssh'}
  console.log(apiResponse.x)
  console.log(apiResponse.hiddenAttribute)
  const foo: number = apiResponse
```

```ts title="unknown"
  const apiResponse: unknown = {hiddenAttribute: 'sssssh'}
  console.log(apiResponse.x)
  console.log(apiResponse.hiddenAttribute)
  const foo: number = apiResponse
```

</CodeSurfer>


<Logo/>

<Notes>

  - Tipos literales: type foo = 'Agua' | 'Tierra' | 'Fuego' | 'Aire'
  - Funciones: Se declara de forma similar a las funciones flecha
  - Array: repeticion de elementos, de cualquier tipo ya definido, o implícito [{name: 'a'}]
  - Tupla: defines a priori el tipo de los elementos. No se puede acceder a índices que no se han definido
  - any: Me da igual lo que venga (Preferiblemente no usarlo. Hay una configuración en tsconfig para evitar que se use)
  - No sé qué es lo que viene, así que tendré que comprobar qué es antes de usarlo. Usado sobre todo cuando trabajamos con código de terceros que no está tipado.
  - ❓️ [never](https://www.typescriptlang.org/docs/handbook/basic-types.html#never): es el tipo que se pone a funciones o métodos que van a devolver un error siempre.

</Notes>

---

## Tipos básicos

---

<CodeSurfer>

```typescript title="Utilización de tipos"
type Developer = {
  name: string
  age: number
  language: Language
}
```

```diff title="Tipo no primitivo" 4[13:23]
```

```typescript title="Union Type (|)"
type NIF: number | string
```

```typescript title="Union Type (|)"
type NIF: number | string

const onePerson: NIF = '12345678'
const anotherPerson: NIF = 12345678
```


```typescript title="Intersection Type (&)"
type Language = 'typescript' | 'bash' | 'sql'
type Person = { name: string }
type Technologies = { language: Language[] }

type developer = Person & Technologies
```

```diff title="Intersection Type (&)" 5
```

```typescript title="Ejemplo" 5,6
type Language = 'typescript' | 'bash' | 'sql'
type Person = { name: string }
type Technologies = { language: Language[] }

type Developer = Person & Technologies
const developer: Developer = {name: 'Segismundo', language: ['sql']}
```

</CodeSurfer>

<Logo/>

<Notes>

  - Union type: puede tomar valores de cualquiera de los tipos
  - solo se pueden usar métodos comunes (toUpperCase)
  - Intersection Type: es la suma de todos sus atributos
  - type BasicPrimitive = number | string | boolean
  - TODO: Ejemplos

</Notes>

----

## Tipos avanzados: Built-in types

  - Generics <T, U>
  - Record<key, value>
  - Partial y Required
  - Pick y Omit
  - keyof
  - Type Assertions

---

<CodeSurfer>


```typescript title="Generics <T, U>"
class Invoice<T> {
  add(T)
}
```

```typescript title="Record <key, value>" 1:6
type Language = 'typescript' | 'bash' | 'sql'
enum Level { Entry, Middle, Top, TenX }
type Expertise = Record<Languages, Level>
const expertise = { 'sql': Level.Entry }

expertise['sql']
```

```typescript title="Partial" 1:8
type HumanDeveloper = {
  name: string
  languages: Language[]
  age: number
  pokemonScore: number
}

type Person = Partial<HumanDeveloper>

type Person = {
  name?: string
  languages?: Language[]
  age?: number
  pokemonScore?: number
}
```

```diff title="Resultado de aplicar Partial" 10:15
```

```typescript title="Required" 1:9
type HumanDeveloper = {
  name?: string
  languages?: Language[]
  age?: number
  pokemonScore?: number
}

type Person = Required<HumanDeveloper>

const person: Person = {
  name: 'Juan',
  language: ['sql'],
  age: 18,
  pokemonScore: 100
}
```

```diff title="Required" 10:15
```

```typescript title="Pick" 1:10
  type HumanDeveloper = {
    name?: string,
    language?: Language[],
    age?: number,
    pokemonScore?: number
  }

type Person = Required<HumanDeveloper>

type Gamer = Pick<Person, 'name' | 'pokemonScore'>
```

```typescript title="Omit" 1:10
  type HumanDeveloper = {
    name: string,
    language: Language[],
    age: number,
    pokemonScore: number
  }

type Person = Omit<HumanDeveloper, 'language' | 'pokemonScore'>

const person: Person = { name: 'Juan', age: '25' }
```

```typescript title="Omit (corregido)" 1:10
type HumanDeveloper = {
  name: string,
  language: Language[],
  age: number,
  pokemonScore: number
}

type Person = Omit<HumanDeveloper, 'language' | 'pokemonScore'>

const person: Person = { name: 'Juan', age: 25 }
```

```typescript title="keyof" 1:8
type HumanDeveloper = {
  name: string,
  language: Language[],
  age: number,
  pokemonScore: number
}

type foo = keyof HumanDeveloper
```

```typescript title="Type assertions" 1:13
type HumanDeveloper = {
  name: string,
  language: Language[],
  age: number,
  pokemonScore: number
}

const foo = <HumanDeveloper>{
  name: 'Segismundo',
  age: 25,
  pokemonScore: 0,
  clashOfClansScore: 100
}

foo.pokemonScore = 0
foo.classOfClansScore = -1
```

```diff title="Type assertions" 1:13,15[1:17]
```

```diff title="Type assertions" 1:13,16[1:22]
```

</CodeSurfer>

<Logo/>

<Notes>

  - Generics <T, U>
  - Record<key, value>
  - Partial y Required
  - Pick y Omit
  - keyof
  - Type Assertions
  - Diferencia entre Partial y Required
  - Error en Omit
  - TODO: Type assertions

</Notes>

---

## Tipos avanzados

---

<CodeSurfer>

```ts title="Interfaces vs tipos 1/3"
interface Person {
  name: string
  age?: number
}

type Person = {
  name: string
  age?: number
}
```

```ts title="Interfaces vs tipos 2/3"
  interface HumanDeveloper {
    name: string
    age: number
  }

  interface HumanDeveloper {
    languages: Language[]
    pokemonScore: number
  }
```

```ts title="Interfaces vs tipos 3/3"
  type Human = {
    name: string
    age: number
  }

  type Developer = {
    languages: Language[]
  }

  type Gamer = {
    pokemonScore: number
  }

  type HumanDeveloper = Human & Developer & Gamer
```

</CodeSurfer>


<Logo/>

<Notes>

  - TODO: Toda interfaz puede ser sustituida por un tipo pero no todos los tipos pueden ser sustituidos por una interfaz
  - ¿Cuál tendría más sentido utilizar aquí?
  - En este caso la interfaz porque no tiene ninguna complejidad
  - Diferencias en cómo se extienden
  - ¿Qué pasa si se define dos tipos con la misma palabra? ¿Y dos interfaces?
  - Interfaz se puede extender y aumentar
  - Tipos: alias, uno u otro, concatenar (interfaces también de otra forma)

</Notes>

---

## Tipado y propiedades de clases

- extends (JS)
- implements
- public (por defecto)
- private
- protected
- readonly
- static (JS)
- abstract

---

<CodeSurfer>

```js title="extends (JS)"
class Person {
  name: string
}

class Developer extends Person {
  language: Language[]
}
```

```diff title="extends (JS)" 5[17:24]
```


```js title="implements" 1:13
interface HumanDeveloper {
  name: string
  age: number
  languages: Language[]
  pokemonScore: number
}

class Person implements HumanDeveloper {
  age: number
  languages: Language[]
  name: string
  pokemonScore: number
}
```

```diff title="implements" 8[14:24]
```


```js title="public" 1:13
class Person implements HumanDeveloper {
  age: number
  languages: Language[]
  name: string
  pokemonScore: number
}

class AwesomePerson implements HumanDeveloper {
  public age: number
  public languages: Language[]
  public name: string
  public pokemonScore: number
}
```

```diff title="public" 9[3:9],10[3:9],11[3:9],12[3:9]
```

```js title="public"
class Person implements HumanDeveloper {
  age: number
  languages: Language[]
  name: string
  pokemonScore: number
}

class AwesomePerson implements HumanDeveloper {
  age: number
  languages: Language[]
  name: string
  pokemonScore: number
}
```


```js title="private" 1:6
class Person {
  age: number
  languages: Language[]
  name: string
  pokemonScore: number
}

class AwesomePerson {
  age: number
  languages: Language[]
  name: string
  private pokemonScore: number
}

const person: AwesomePerson = new AwesomePerson()
person.pokemonScore = 1000000
```

```diff title="private" 8:13
```

```diff title="private" 14:16
```

```js title="protected" 1:11
class Person {
  age: number
  name: string
  private pokemonScore: number
}

class BoredPerson extends Person {
  hackScore() {
    this.pokemonScore = 1000000
  }
}

class AwesomePerson {
  age: number
  name: string
  protected pokemonScore: number
}

class BusyPerson extends AwesomePerson {
  hackScore() {
    this.pokemonScore = 1000000
  }
}
```

```diff title="protected" 4[3:10],7[18:25],9
```

```diff title="protected" 16[3:12],19[18:25],21
```


```ts title="readonly"
class Person implements HumanDeveloper {
  age: number
  readonly languages: Language[]
  readonly name: string
  pokemonScore: number
}

const foo: Person = new Person()
foo.age =1
foo.name = 'Felipe'
```

```diff title="readonly" 3[3:11],4[3:11]
```

```diff title="readonly" 9,10
```

```typescript title="static (JS)" 1:7
class Person implements HumanDeveloper {
  static human: boolean = true
  age: number
  languages: Language[]
  name: string
  pokemonScore: number
}

const person = new Person()
person.age = 25
Person.human
```

```diff title="static (JS)" 2[3:9]
```

```diff title="static (JS)" 1[7:13],2[3:15],11
```

</CodeSurfer>

---

<CodeSurfer>

```ts title="abstract" 1:7
abstract class Person {
  name: string

  protected speak(text: string) { console.log(text) }

  abstract sayHello(seconds: number): void
}

class Developer extends Person {
  sayHello(seconds: number) {
    setTimeout(() => this.speak('Hello World!'), seconds)
  }
}

const developer: Developer = new Developer()

developer.sayHello(1000)
```

```diff title="abstract: definicion y método abstracto" 1[1:9],6
```

```diff title="abstract: implementación de la clase abstracta" 6,8:17
```

</CodeSurfer>

<Logo/>

<Notes>

  - Doc: TypeScript allows us to mark a class as abstract. This tells TypeScript that the class is only meant to be extended from, and that certain members need to be filled in by any subclass to actually create an instance.
  - extends: ¿les suena de otro lenguage?
  - TODO: Comentar Michael/Ulises readonly array

</Notes>

---

## Proyecto

---

### Proyecto: Primeros pasos

1. Inicializar Proyecto
    - `> npm init`
    - `> npm init -y`
1. Instalar Typescript
    - `> npm install typescript --save-dev`
1. Inicializar configuración de Typescript
    - `> tsc --init`
1. Añadir y configurar test runner
    1. `> npm install jest @types/jest ts-jest --save-dev`
    1. `> jest --init`

<Logo/>

<Notes>

  - Quizás mencionar algo más de tsconfig?
  - Quizás mencionar algo de tsconfig para prod y para dev?

</Notes>

---

## Proyecto: Build

```
> build
> src
> tests
```

<Logo/>

<Notes>

  - No entrar en detalles de SOLID!!

</Notes>

---

## Testing


---

## Testing

<CodeSurfer>

```typescript title="Los test permiten conocer el comportamiento del código sin leerlo"
describe ('This pokemon should'...
  describe ('Wins fight with'...
    it ('Ground pokemon'...
    it ('Fire pokemon'...
    it ('Water pokemon'...
  describe ('Throw error if fight with')
    it ('fully evolved'...
    it ('half ground'...
  ...
```

</CodeSurfer>

---

## Testing

<CodeSurfer>

```json title="Ejemplo de jest.config.json"
{
  "roots": ["<rootDir>/test"],
  "testMatch": ["**/__tests__/**/*.+(ts|js)", "**/?(*.)+(spec|test).+(ts|js)"],
  "transform": {
    "^.+\\.(ts)?$": "ts-jest"
  },
  "setupFilesAfterEnv": ["<rootDir>/test/setupTests.ts"]
}
```

</CodeSurfer>

<Logo/>

<Notes>

  1. Tests con TypeScript y Jest
      1. Poner dibujo: copa de tests
      2. describe / it
      3. Helpers: repaso builders / expects por clases
  1. jest.config.json
      2. Explicar un fichero de ejemplo
      3. setupTests.ts

</Notes>

---

## De JS a TS

<Logo/>

<Notes>

  - Entender como si JS y TS no fueran compatibles, aunque si puedan serlo

</Notes>

---

## Recursos

- [Tipos básicos en TypeScript](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html)
- [Utility Types en TypeScript](https://www.typescriptlang.org/docs/handbook/utility-types.html)
- [Testing con Jest](https://jestjs.io/)
